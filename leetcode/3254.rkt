#lang racket

(define (results-array nums k)
  (let* ((len (length nums))
         (sublist (lambda (lst from to)
                    (drop (take lst to) from)))
         (result '())
         (consec-and-sorted? (lambda (lst)
                               (let loop ((l lst)
                                          (prev -1))
                                 (cond ((empty? l) #t)
                                       ((= prev -1) (loop (cdr l)
                                                          (car l)))
                                       ((not (= (car l) (+ prev 1))) #f)
                                       (else (loop (cdr l)
                                                   (car l)))))))
         (list-power (lambda (lst)
                  (if (consec-and-sorted? lst)
                      (apply max lst)
                      -1))))
    (for ((i (range (+ (- len k) 1))))
      (let ((subl (sublist nums i (+ i k))))
        (set! result (cons (list-power subl) result))))
    (reverse result)))

(results-array '(1 2 3 4 3 2 5) 3)
(results-array '(2 2 2 2 2) 4)
