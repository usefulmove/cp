#lang racket

(define (to-hex num)
  (letrec ((invert (lambda (bits) (map
                                   (lambda (b) (if (equal? b #\1) #\0 #\1))
                                   bits)))
           (fill (lambda (lst c n)
                   (append lst (make-list (- n (length lst)) c))))
           (get-bits (lambda (n)
                       (if (< n 0)
                           (invert (fill (get-bits (- (abs n) 1)) #\0 32))
                           (reverse (string->list (number->string n 2))))))
           (convert (lambda (bits) (match bits
                                     ('(#\0 #\0 #\0 #\0) #\0)
                                     ('(#\1 #\0 #\0 #\0) #\1)
                                     ('(#\0 #\1 #\0 #\0) #\2)
                                     ('(#\1 #\1 #\0 #\0) #\3)
                                     ('(#\0 #\0 #\1 #\0) #\4)
                                     ('(#\1 #\0 #\1 #\0) #\5)
                                     ('(#\0 #\1 #\1 #\0) #\6)
                                     ('(#\1 #\1 #\1 #\0) #\7)
                                     ('(#\0 #\0 #\0 #\1) #\8)
                                     ('(#\1 #\0 #\0 #\1) #\9)
                                     ('(#\0 #\1 #\0 #\1) #\a)
                                     ('(#\1 #\1 #\0 #\1) #\b)
                                     ('(#\0 #\0 #\1 #\1) #\c)
                                     ('(#\1 #\0 #\1 #\1) #\d)
                                     ('(#\0 #\1 #\1 #\1) #\e)
                                     ('(#\1 #\1 #\1 #\1) #\f)))))
    (let loop ((bs (get-bits num))
               (out '()))
      (cond ((empty? bs) (list->string out))
            ((< (length bs) 4) (loop '()
                                     (cons (convert (fill bs #\0 4)) out)))
            (else (loop (drop bs 4)
                        (cons (convert (take bs 4)) out)))))))

(to-hex 26)
(to-hex -1)
